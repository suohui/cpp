# 1、UML类图

## 1.1、六大关系：

泛化（Generalization）
实现（Realization）

关联（Association）
依赖（Dependency）

聚合（Aggregation）
组合（Composition）

## 1.2、UML语法

虚线箭头指向依赖；
实线箭头指向关联；

虚线三角指向接口；
实线三角指向父类；

空心菱形能分离而独立存在，是聚合；
实心菱形紧密关联不可分，是组合；

## 1.3、符号表示

### 1.3.1、泛化

**关系：**泛化关系（is a）指子类或者子接口继承了父类或者父接口，并可以增加自己的新功能。
**体现：**在C++中，泛化通过类的继承来实现
**箭头：**带三角形箭头的实线，从子类或者子接口指向父类或者父接口。

![v2-10af720d19484706cb7733039da49853_r](D:\CppNote\Image\UML类图\v2-10af720d19484706cb7733039da49853_r.jpg)

### 1.3.2、实现

**关系：**实现（is a）指的是一个类实现一个或者多个接口，这是类和接口之间常见的关系。
**体现：**在C++中，实现关系通过类实现接口来实现，即：一个类实现某个接口
**箭头：**带三角形箭头的虚线，从子类指向接口。

![v2-89e9be817d299e5bd65cb719a909b562_720w](D:\CppNote\Image\UML类图\v2-89e9be817d299e5bd65cb719a909b562_720w.jpg)

### 1.3.3、依赖

**关系：**依赖（use a）指的类和类之间的关系，一个类依赖于另外一个类的定义，这种关系是单向的。如
**体现：**在C++中，如果A依赖于B，则B体现为局部变量、方法的参数或静态方法的调用等。
**箭头：**带箭头的虚线，指向被依赖对象

![v2-a4aba4d643535f99f54ecc913092140e_720w](D:\CppNote\Image\UML类图\v2-a4aba4d643535f99f54ecc913092140e_720w.jpg)

![20150713183642200](D:\CppNote\Image\UML\20150713183642200.jpg)

### 1.3.4、关联

**关系：**关联（has a）表示类和类之间的连接，使得一个类知道另一个类的属性和方法。
			1、关联关系有双向关联和单向关联。双向关联：两个类都知道另一个类的公共属性和操作。单向关联：只有一个类知道另外一个类的公共属性和操作。
			2、大多数关联应该是单向的，单向关系更容易建立和维护，有助于寻找可复用的类。
**体现：**在C++中，如果A依赖于B，则B体现为A的成员变量
**箭头：**双线关联为实线，单向关联为带箭头实线，箭头从拥有者指向被拥有者。

![v2-3a1605e411155370e08ed67913f2dfa9_r](D:\CppNote\Image\UML类图\v2-3a1605e411155370e08ed67913f2dfa9_r.jpg)

![20150713183602059](D:\CppNote\Image\UML\20150713183602059.jpg)

### 1.3.5、聚合

**关系：**表示整体与部分的关系，且部分可以离开整体而单独存在。体现的是A对象可以包含B对象，但B对象不是A对象的组成部分。具体表现为，如果A由B聚合成，表现为A包含有B的全局对象，但是B对象可以不在A创建的时刻创建。
**体现：**在C++中，聚合关系通过将被聚合者的（数组）指针作为内部成员来实现的
**箭头：**带空心菱形的实心线，菱形指向整体

![v2-737512e7bcc20dc7736486e649818089_720w](D:\CppNote\Image\UML类图\v2-737512e7bcc20dc7736486e649818089_720w.jpg)

![20150713183615411](D:\CppNote\Image\UML\20150713183615411.jpg)

### 1.3.6、组合

**关系：**是整体与部分的关系，但部分不能离开整体而单独存在，部分和整体的生命周期一致。如果A由B组成，表现为A包含有B的全局对象，并且B对象在A创建的时刻创建。
**体现：**在C++中，组合关系是通过成员变量来实现的
**箭头：**带实心菱形的实心线，菱形指向整体

![v2-b1515400faf979d45620244fbf7fbdff_720w](D:\CppNote\Image\UML类图\v2-b1515400faf979d45620244fbf7fbdff_720w.jpg)

![20150713183630882](D:\CppNote\Image\UML\20150713183630882.jpg)

## 1.4、案例

各种关系的强弱顺序：
	泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖 

![157774008_1_20190401041508721](D:\CppNote\Image\UML类图\157774008_1_20190401041508721.jpg)

如上图所示，我们先创建一个抽象类动物Animal，动物是需要喝水的，所以创建一个水类Water。动物喝水它肯定需要一个方法名字叫drink，那么这方法肯定需要一个的参数叫water，类型为Water。那么，动物是依赖于水的，这样动物和水之间就形成了一个依赖关系。 动物分很多种类，现在我们简单来讲有哺乳动物Mammal，也有鸟类bird，它们两类都继承（泛化Generalization）于动物。鸟类是需要有翅膀才能飞，所以就需要一个翅膀类Wing，鸟有翅膀，所以给鸟类增加一个成员变量wing，类型为Wing。翅膀是不能离开鸟类单独存在的，所以翅膀和鸟类之间就形成一种组合关系。鸭子也是鸟类的一种，所以鸭子类继承与鸭子类Duck，但是有一种特殊的鸭子唐老鸭他是会说话Talk也会演电影Act，所以唐老鸭类DonalDuck继承于Duck，将Talk和Act分别设计为两个接口，DonalDuck类对这两个接口进行了实现（Realization）。

对于哺乳动物来说也有很多，我们简单来举两个例子。一个是狼类Wolf，另一个是羊，他们都是继承于哺乳动物。狼吃羊，羊也会躲避狼，所以他们之间会有关联关系。一般狼不会单独存在的，他们会形成一个狼群，所以很多的狼在一起就聚合成了一个狼群类WolfPack。换言之，某一只狼离开了这个狼群，这个狼群依然存在。一匹狼离开了狼群成为了孤狼，但是它也是能够单独存在，所以它们之间是一种聚合关系而不是组合关系。